{"version":3,"sources":["attach-shared-listeners.ts"],"names":["attachSharedListeners","webSocketInstance","url","onmessage","message","forEach","subscriber","optionsRef","current","onMessage","filter","setLastMessage","onclose","event","onClose","setReadyState","ReadyState","CLOSED","sharedWebSockets","shouldReconnect","reconnectAttempts","DEFAULT_RECONNECT_LIMIT","reconnectCount","reconnect","setTimeout","reconnectInterval","DEFAULT_RECONNECT_INTERVAL_MS","onReconnectStop","console","error","onerror","onError","onopen","onOpen","OPEN"],"mappings":"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","sourcesContent":["import { sharedWebSockets } from './globals';\r\nimport { DEFAULT_RECONNECT_LIMIT, DEFAULT_RECONNECT_INTERVAL_MS, ReadyState } from './constants';\r\nimport { getSubscribers } from './manage-subscribers';\r\nimport type { WebSocketEventMap } from './types';\r\n\r\nexport const attachSharedListeners = (\r\n  webSocketInstance: WebSocket,\r\n  url: string,\r\n) => {\r\n  \r\n  webSocketInstance.onmessage = (message: WebSocketEventMap['message']) => {\r\n    getSubscribers(url).forEach(subscriber => {\r\n      if (subscriber.optionsRef.current.onMessage) {\r\n        subscriber.optionsRef.current.onMessage(message);\r\n      }\r\n\r\n      if (\r\n        typeof subscriber.optionsRef.current.filter === 'function' &&\r\n        subscriber.optionsRef.current.filter(message) !== true\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      subscriber.setLastMessage(message);\r\n    });\r\n  };\r\n\r\n  webSocketInstance.onclose = (event: WebSocketEventMap['close']) => {\r\n    getSubscribers(url).forEach(subscriber => {\r\n      if (subscriber.optionsRef.current.onClose) {\r\n        subscriber.optionsRef.current.onClose(event);\r\n      }\r\n\r\n      subscriber.setReadyState(ReadyState.CLOSED);\r\n    });\r\n    \r\n    delete sharedWebSockets[url];\r\n\r\n    getSubscribers(url).forEach(subscriber => {\r\n      if (\r\n        subscriber.optionsRef.current.shouldReconnect &&\r\n        subscriber.optionsRef.current.shouldReconnect(event)\r\n      ) {\r\n        const reconnectAttempts = subscriber.optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT;\r\n        if (subscriber.reconnectCount.current < reconnectAttempts) {\r\n          if (subscriber.reconnectCount.current++ === 0) {\r\n            subscriber.reconnect.current();\r\n          } else {\r\n            setTimeout(() => {\r\n              subscriber.reconnect.current();\r\n            }, subscriber.optionsRef.current.reconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\r\n          }\r\n        } else {\r\n          subscriber.optionsRef.current.onReconnectStop && subscriber.optionsRef.current.onReconnectStop(subscriber.optionsRef.current.reconnectAttempts as number);\r\n          console.error(`Max reconnect attempts of ${reconnectAttempts} exceeded`);\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  webSocketInstance.onerror = (error: WebSocketEventMap['error']) => {\r\n    getSubscribers(url).forEach(subscriber => {\r\n      if (subscriber.optionsRef.current.onError) {\r\n        subscriber.optionsRef.current.onError(error);\r\n      }\r\n    });\r\n  };\r\n\r\n  webSocketInstance.onopen = () => {\r\n    getSubscribers(url).forEach(subscriber => {\r\n      subscriber.reconnectCount.current = 0;\r\n      if (subscriber.optionsRef.current.onOpen) {\r\n        subscriber.optionsRef.current.onOpen();\r\n      }\r\n\r\n      subscriber.setReadyState(ReadyState.OPEN);\r\n    });\r\n  };\r\n};\r\n"]}