"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.attachSharedListeners = void 0;

var _globals = require("./globals");

var _constants = require("./constants");

var _manageSubscribers = require("./manage-subscribers");

const attachSharedListeners = (webSocketInstance, url) => {
  webSocketInstance.onmessage = message => {
    (0, _manageSubscribers.getSubscribers)(url).forEach(subscriber => {
      if (subscriber.optionsRef.current.onMessage) {
        subscriber.optionsRef.current.onMessage(message);
      }

      if (typeof subscriber.optionsRef.current.filter === 'function' && subscriber.optionsRef.current.filter(message) !== true) {
        return;
      }

      subscriber.setLastMessage(message);
    });
  };

  webSocketInstance.onclose = event => {
    (0, _manageSubscribers.getSubscribers)(url).forEach(subscriber => {
      if (subscriber.optionsRef.current.onClose) {
        subscriber.optionsRef.current.onClose(event);
      }

      subscriber.setReadyState(_constants.ReadyState.CLOSED);
    });
    delete _globals.sharedWebSockets[url];
    (0, _manageSubscribers.getSubscribers)(url).forEach(subscriber => {
      if (subscriber.optionsRef.current.shouldReconnect && subscriber.optionsRef.current.shouldReconnect(event)) {
        var _subscriber$optionsRe;

        const reconnectAttempts = (_subscriber$optionsRe = subscriber.optionsRef.current.reconnectAttempts) !== null && _subscriber$optionsRe !== void 0 ? _subscriber$optionsRe : _constants.DEFAULT_RECONNECT_LIMIT;

        if (subscriber.reconnectCount.current < reconnectAttempts) {
          if (subscriber.reconnectCount.current++ === 0) {
            subscriber.reconnect.current();
          } else {
            var _subscriber$optionsRe2;

            setTimeout(() => {
              subscriber.reconnect.current();
            }, (_subscriber$optionsRe2 = subscriber.optionsRef.current.reconnectInterval) !== null && _subscriber$optionsRe2 !== void 0 ? _subscriber$optionsRe2 : _constants.DEFAULT_RECONNECT_INTERVAL_MS);
          }
        } else {
          subscriber.optionsRef.current.onReconnectStop && subscriber.optionsRef.current.onReconnectStop(subscriber.optionsRef.current.reconnectAttempts);
          console.error(`Max reconnect attempts of ${reconnectAttempts} exceeded`);
        }
      }
    });
  };

  webSocketInstance.onerror = error => {
    (0, _manageSubscribers.getSubscribers)(url).forEach(subscriber => {
      if (subscriber.optionsRef.current.onError) {
        subscriber.optionsRef.current.onError(error);
      }
    });
  };

  webSocketInstance.onopen = () => {
    (0, _manageSubscribers.getSubscribers)(url).forEach(subscriber => {
      subscriber.reconnectCount.current = 0;

      if (subscriber.optionsRef.current.onOpen) {
        subscriber.optionsRef.current.onOpen();
      }

      subscriber.setReadyState(_constants.ReadyState.OPEN);
    });
  };
};

exports.attachSharedListeners = attachSharedListeners;
//# sourceMappingURL=attach-shared-listeners.js.map