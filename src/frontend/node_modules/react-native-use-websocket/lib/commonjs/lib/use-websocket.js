"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useWebSocket = void 0;

var _react = require("react");

var _constants = require("./constants");

var _createOrJoin = require("./create-or-join");

var _getUrl = require("./get-url");

var _proxy = _interopRequireDefault(require("./proxy"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const useWebSocket = (url, options = _constants.DEFAULT_OPTIONS, connect = true) => {
  const [lastMessage, setLastMessage] = (0, _react.useState)({});
  const [readyState, setReadyState] = (0, _react.useState)({});
  const lastJsonMessage = (0, _react.useMemo)(() => {
    if (lastMessage) {
      try {
        return JSON.parse(lastMessage.data);
      } catch (e) {
        return _constants.UNPARSABLE_JSON_OBJECT;
      }
    }

    return null;
  }, [lastMessage]);
  const convertedUrl = (0, _react.useRef)("");
  const webSocketRef = (0, _react.useRef)(null);
  const startRef = (0, _react.useRef)(() => {});
  const reconnectCount = (0, _react.useRef)(0);
  const messageQueue = (0, _react.useRef)([]);
  const webSocketProxy = (0, _react.useRef)(null);
  const optionsCache = (0, _react.useRef)(options);
  const readyStateFromUrl = convertedUrl.current && readyState[convertedUrl.current] !== undefined ? readyState[convertedUrl.current] : url !== null && connect === true ? _constants.ReadyState.CONNECTING : _constants.ReadyState.UNINSTANTIATED;
  const stringifiedQueryParams = options.queryParams ? JSON.stringify(options.queryParams) : null;
  const sendMessage = (0, _react.useCallback)(message => {
    if (webSocketRef.current && webSocketRef.current.readyState === _constants.ReadyState.OPEN) {
      webSocketRef.current.send(message);
    } else {
      messageQueue.current.push(message);
    }
  }, []);
  const sendJsonMessage = (0, _react.useCallback)(message => {
    sendMessage(JSON.stringify(message));
  }, [sendMessage]);
  const getWebSocket = (0, _react.useCallback)(() => {
    var _optionsCache$current;

    if (((_optionsCache$current = optionsCache.current) === null || _optionsCache$current === void 0 ? void 0 : _optionsCache$current.share) !== true && null !== webSocketRef.current) {
      return webSocketRef.current;
    }

    if (webSocketProxy.current === null && webSocketRef.current && startRef.current) {
      webSocketProxy.current = (0, _proxy.default)(webSocketRef.current, startRef);
    } else {
      return webSocketProxy.current;
    }

    return webSocketProxy.current;
  }, [optionsCache]);
  (0, _react.useEffect)(() => {
    if (url !== null && connect === true) {
      let removeListeners;
      let expectClose = false;

      const start = async () => {
        convertedUrl.current = await (0, _getUrl.getUrl)(url, optionsCache);

        const protectedSetLastMessage = message => {
          if (!expectClose) {
            setLastMessage(message);
          }
        };

        const protectedSetReadyState = state => {
          if (!expectClose) {
            setReadyState(prev => ({ ...prev,
              [convertedUrl.current]: state
            }));
          }
        };

        removeListeners = (0, _createOrJoin.createOrJoinSocket)(webSocketRef, convertedUrl.current, protectedSetReadyState, optionsCache, protectedSetLastMessage, startRef, reconnectCount);
      };

      startRef.current = () => {
        if (!expectClose) {
          var _removeListeners;

          if (webSocketProxy.current) webSocketProxy.current = null;
          (_removeListeners = removeListeners) === null || _removeListeners === void 0 ? void 0 : _removeListeners();
          start();
        }
      };

      start();
      return () => {
        var _removeListeners2;

        expectClose = true;
        if (webSocketProxy.current) webSocketProxy.current = null;
        (_removeListeners2 = removeListeners) === null || _removeListeners2 === void 0 ? void 0 : _removeListeners2();
        setLastMessage({});
      };
    } else {
      return;
    }
  }, [url, connect, stringifiedQueryParams, optionsCache, sendMessage]);
  (0, _react.useEffect)(() => {
    if (readyStateFromUrl === _constants.ReadyState.OPEN) {
      messageQueue.current.splice(0).forEach(message => {
        sendMessage(message);
      });
    }
  }, [readyStateFromUrl]);
  return {
    sendMessage,
    sendJsonMessage,
    lastMessage,
    lastJsonMessage,
    readyState: readyStateFromUrl,
    getWebSocket
  };
};

exports.useWebSocket = useWebSocket;
//# sourceMappingURL=use-websocket.js.map