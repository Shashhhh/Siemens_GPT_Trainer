import { setUpSocketIOPing } from './socket-io';
import { DEFAULT_RECONNECT_LIMIT, DEFAULT_RECONNECT_INTERVAL_MS, ReadyState } from './constants';
export const attachListeners = (webSocketInstance, setters, optionsRef, reconnect, reconnectCount) => {
  const {
    setLastMessage,
    setReadyState
  } = setters;
  let interval;
  let reconnectTimeout;

  if (optionsRef.current.fromSocketIO) {
    interval = setUpSocketIOPing(webSocketInstance);
  }

  webSocketInstance.onmessage = message => {
    optionsRef.current.onMessage && optionsRef.current.onMessage(message);

    if (typeof optionsRef.current.filter === 'function' && optionsRef.current.filter(message) !== true) {
      return;
    }

    setLastMessage(message);
  };

  webSocketInstance.onopen = () => {
    optionsRef.current.onOpen && optionsRef.current.onOpen();
    reconnectCount.current = 0;
    setReadyState(ReadyState.OPEN);
  };

  webSocketInstance.onclose = event => {
    optionsRef.current.onClose && optionsRef.current.onClose(event);
    setReadyState(ReadyState.CLOSED);

    if (optionsRef.current.shouldReconnect && optionsRef.current.shouldReconnect(event)) {
      var _optionsRef$current$r;

      const reconnectAttempts = (_optionsRef$current$r = optionsRef.current.reconnectAttempts) !== null && _optionsRef$current$r !== void 0 ? _optionsRef$current$r : DEFAULT_RECONNECT_LIMIT;

      if (reconnectCount.current < reconnectAttempts) {
        var _optionsRef$current$r2;

        reconnectTimeout = setTimeout(() => {
          reconnectCount.current++;
          reconnect();
        }, (_optionsRef$current$r2 = optionsRef.current.reconnectInterval) !== null && _optionsRef$current$r2 !== void 0 ? _optionsRef$current$r2 : DEFAULT_RECONNECT_INTERVAL_MS);
      } else {
        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(reconnectAttempts);
        console.error(`Max reconnect attempts of ${reconnectAttempts} exceeded`);
      }
    }
  };

  webSocketInstance.onerror = error => {
    optionsRef.current.onError && optionsRef.current.onError(error);

    if (optionsRef.current.retryOnError) {
      var _optionsRef$current$r3;

      if (reconnectCount.current < ((_optionsRef$current$r3 = optionsRef.current.reconnectAttempts) !== null && _optionsRef$current$r3 !== void 0 ? _optionsRef$current$r3 : DEFAULT_RECONNECT_LIMIT)) {
        var _optionsRef$current$r4;

        reconnectTimeout = setTimeout(() => {
          reconnectCount.current++;
          reconnect();
        }, (_optionsRef$current$r4 = optionsRef.current.reconnectInterval) !== null && _optionsRef$current$r4 !== void 0 ? _optionsRef$current$r4 : DEFAULT_RECONNECT_INTERVAL_MS);
      } else {
        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(optionsRef.current.reconnectAttempts);
        console.error(`Max reconnect attempts of ${optionsRef.current.reconnectAttempts} exceeded`);
      }
    }
  };

  return () => {
    setReadyState(ReadyState.CLOSING);
    if (reconnectTimeout) clearTimeout(reconnectTimeout);
    webSocketInstance.close();
    if (interval) clearInterval(interval);
  };
};
//# sourceMappingURL=attach-listener.js.map