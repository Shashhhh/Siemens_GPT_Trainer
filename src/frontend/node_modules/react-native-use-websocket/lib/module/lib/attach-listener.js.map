{"version":3,"sources":["attach-listener.ts"],"names":["setUpSocketIOPing","DEFAULT_RECONNECT_LIMIT","DEFAULT_RECONNECT_INTERVAL_MS","ReadyState","attachListeners","webSocketInstance","setters","optionsRef","reconnect","reconnectCount","setLastMessage","setReadyState","interval","reconnectTimeout","current","fromSocketIO","onmessage","message","onMessage","filter","onopen","onOpen","OPEN","onclose","event","onClose","CLOSED","shouldReconnect","reconnectAttempts","setTimeout","reconnectInterval","onReconnectStop","console","error","onerror","onError","retryOnError","CLOSING","clearTimeout","close","clearInterval"],"mappings":"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","sourcesContent":["import type { MutableRefObject } from 'react';\r\nimport { setUpSocketIOPing } from './socket-io';\r\nimport { DEFAULT_RECONNECT_LIMIT, DEFAULT_RECONNECT_INTERVAL_MS, ReadyState } from './constants';\r\nimport type { Options, WebSocketEventMap } from './types';\r\n\r\nexport interface Setters {\r\n  setLastMessage: (message: WebSocketEventMap['message']) => void;\r\n  setReadyState: (readyState: ReadyState) => void;\r\n}\r\n\r\nexport const attachListeners = (\r\n    webSocketInstance: WebSocket,\r\n    setters: Setters,\r\n    optionsRef: MutableRefObject<Options>,\r\n    reconnect: () => void,\r\n    reconnectCount: MutableRefObject<number>,\r\n  ): (() => void) => {\r\n  const { setLastMessage, setReadyState } = setters;\r\n\r\n  let interval: NodeJS.Timeout;\r\n  let reconnectTimeout: NodeJS.Timeout;\r\n\r\n  if (optionsRef.current.fromSocketIO) {\r\n    interval = setUpSocketIOPing(webSocketInstance);\r\n  }\r\n\r\n  webSocketInstance.onmessage = (message: WebSocketEventMap['message']) => {\r\n    optionsRef.current.onMessage && optionsRef.current.onMessage(message);\r\n    if (typeof optionsRef.current.filter === 'function' && optionsRef.current.filter(message) !== true) {\r\n      return;\r\n    }\r\n    setLastMessage(message);\r\n  };\r\n  webSocketInstance.onopen = () => {\r\n    optionsRef.current.onOpen && optionsRef.current.onOpen();\r\n    reconnectCount.current = 0;\r\n    setReadyState(ReadyState.OPEN);\r\n  };\r\n  webSocketInstance.onclose = (event: WebSocketEventMap['close']) => {\r\n    optionsRef.current.onClose && optionsRef.current.onClose(event);\r\n    setReadyState(ReadyState.CLOSED);\r\n    if (optionsRef.current.shouldReconnect && optionsRef.current.shouldReconnect(event)) {\r\n      const reconnectAttempts = optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT;\r\n      if (reconnectCount.current < reconnectAttempts) {\r\n        reconnectTimeout = setTimeout(() => {\r\n          reconnectCount.current++;\r\n          reconnect();\r\n        }, optionsRef.current.reconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\r\n      } else {\r\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(reconnectAttempts);\r\n        console.error(`Max reconnect attempts of ${reconnectAttempts} exceeded`);\r\n      }\r\n    }\r\n  };\r\n  webSocketInstance.onerror = (error: WebSocketEventMap['error']) => {\r\n    optionsRef.current.onError && optionsRef.current.onError(error);\r\n\r\n    if (optionsRef.current.retryOnError) {\r\n      if (reconnectCount.current < (optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT)) {\r\n        reconnectTimeout = setTimeout(() => {\r\n          reconnectCount.current++;\r\n          reconnect();\r\n        }, optionsRef.current.reconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\r\n      } else {\r\n        optionsRef.current.onReconnectStop && optionsRef.current.onReconnectStop(optionsRef.current.reconnectAttempts as number);\r\n        console.error(`Max reconnect attempts of ${optionsRef.current.reconnectAttempts} exceeded`);\r\n      }\r\n    }\r\n  };\r\n\r\n  return () => {\r\n    setReadyState(ReadyState.CLOSING);\r\n    if (reconnectTimeout) clearTimeout(reconnectTimeout)\r\n    webSocketInstance.close();\r\n    if (interval) clearInterval(interval);\r\n  };\r\n};\r\n"]}