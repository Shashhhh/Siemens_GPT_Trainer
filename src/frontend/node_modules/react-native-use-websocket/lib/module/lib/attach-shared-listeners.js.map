{"version":3,"sources":["attach-shared-listeners.ts"],"names":["sharedWebSockets","DEFAULT_RECONNECT_LIMIT","DEFAULT_RECONNECT_INTERVAL_MS","ReadyState","getSubscribers","attachSharedListeners","webSocketInstance","url","onmessage","message","forEach","subscriber","optionsRef","current","onMessage","filter","setLastMessage","onclose","event","onClose","setReadyState","CLOSED","shouldReconnect","reconnectAttempts","reconnectCount","reconnect","setTimeout","reconnectInterval","onReconnectStop","console","error","onerror","onError","onopen","onOpen","OPEN"],"mappings":"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","sourcesContent":["import { sharedWebSockets } from './globals';\r\nimport { DEFAULT_RECONNECT_LIMIT, DEFAULT_RECONNECT_INTERVAL_MS, ReadyState } from './constants';\r\nimport { getSubscribers } from './manage-subscribers';\r\nimport type { WebSocketEventMap } from './types';\r\n\r\nexport const attachSharedListeners = (\r\n  webSocketInstance: WebSocket,\r\n  url: string,\r\n) => {\r\n  \r\n  webSocketInstance.onmessage = (message: WebSocketEventMap['message']) => {\r\n    getSubscribers(url).forEach(subscriber => {\r\n      if (subscriber.optionsRef.current.onMessage) {\r\n        subscriber.optionsRef.current.onMessage(message);\r\n      }\r\n\r\n      if (\r\n        typeof subscriber.optionsRef.current.filter === 'function' &&\r\n        subscriber.optionsRef.current.filter(message) !== true\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      subscriber.setLastMessage(message);\r\n    });\r\n  };\r\n\r\n  webSocketInstance.onclose = (event: WebSocketEventMap['close']) => {\r\n    getSubscribers(url).forEach(subscriber => {\r\n      if (subscriber.optionsRef.current.onClose) {\r\n        subscriber.optionsRef.current.onClose(event);\r\n      }\r\n\r\n      subscriber.setReadyState(ReadyState.CLOSED);\r\n    });\r\n    \r\n    delete sharedWebSockets[url];\r\n\r\n    getSubscribers(url).forEach(subscriber => {\r\n      if (\r\n        subscriber.optionsRef.current.shouldReconnect &&\r\n        subscriber.optionsRef.current.shouldReconnect(event)\r\n      ) {\r\n        const reconnectAttempts = subscriber.optionsRef.current.reconnectAttempts ?? DEFAULT_RECONNECT_LIMIT;\r\n        if (subscriber.reconnectCount.current < reconnectAttempts) {\r\n          if (subscriber.reconnectCount.current++ === 0) {\r\n            subscriber.reconnect.current();\r\n          } else {\r\n            setTimeout(() => {\r\n              subscriber.reconnect.current();\r\n            }, subscriber.optionsRef.current.reconnectInterval ?? DEFAULT_RECONNECT_INTERVAL_MS);\r\n          }\r\n        } else {\r\n          subscriber.optionsRef.current.onReconnectStop && subscriber.optionsRef.current.onReconnectStop(subscriber.optionsRef.current.reconnectAttempts as number);\r\n          console.error(`Max reconnect attempts of ${reconnectAttempts} exceeded`);\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  webSocketInstance.onerror = (error: WebSocketEventMap['error']) => {\r\n    getSubscribers(url).forEach(subscriber => {\r\n      if (subscriber.optionsRef.current.onError) {\r\n        subscriber.optionsRef.current.onError(error);\r\n      }\r\n    });\r\n  };\r\n\r\n  webSocketInstance.onopen = () => {\r\n    getSubscribers(url).forEach(subscriber => {\r\n      subscriber.reconnectCount.current = 0;\r\n      if (subscriber.optionsRef.current.onOpen) {\r\n        subscriber.optionsRef.current.onOpen();\r\n      }\r\n\r\n      subscriber.setReadyState(ReadyState.OPEN);\r\n    });\r\n  };\r\n};\r\n"]}